// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3543.Team3543Robot.commands;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import org.usfirst.frc3543.Team3543Robot.OI;
import org.usfirst.frc3543.Team3543Robot.Robot;
import org.usfirst.frc3543.Team3543Robot.RobotMap;
import org.usfirst.frc3543.Team3543Robot.subsystems.VisionSubsystem;
import org.usfirst.frc3543.Team3543Robot.util.GearDropConsumer;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import ttfft.vision.GearDrop;

import ttfft.vision.Settings;


/**
 * This is a command group where we continually add a sequential command
 */
public class ApproachGearDropCommand extends CommandGroup implements GearDropConsumer {
	
	public static final Logger LOGGER = Logger.getLogger(ApproachGearDropCommand.class.getSimpleName());
	
	public static final double MIN_OFFSET = 0.75;	// offset in inches from center
	public static final long MAX_GEARDROP_AGE = 300;	// milliseconds
	public static final long DEFAULT_MAX_SEARCH_TIME = 15000;	// 15 seconds
	public static final double SEARCH_ANGLE_DEGREES = 5;	// degrees to turn while searching
	
	public static final double CUTOFF_DISTANCE = 36;	// inches
	public static final double CUTOFF_DISTANCE_TARGET = 24;	// inches
	
	protected int lastSearchAngleCtr = 0;
	public static final double MAX_SPEED = RobotMap.MAX_SPEED;
	public static final double MIN_SPEED = RobotMap.MIN_SPEED;
	
	GearDrop gearDrop = null;
	Command currentCommand = null;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public ApproachGearDropCommand() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.visionSubsystem);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveLine);
        
        // seed the first command.  This is just a "find the next command" command
    }

    // Called just before this Command runs the first time
    protected void initialize() {    	
    	evaluateNextCommand();    	
    	super.initialize();
    }
    
    protected boolean gearDropIsOffsetTooMuch(GearDrop gearDrop) {
    	return Math.abs(gearDrop.offsetFromCenter) >= MIN_OFFSET;
    }

    protected void needNewGearDrop() {
    	gearDrop = null;
    }
    
    protected Command evaluateNextCommand() {
    	Command command = null;
    	// Do we have the gear drop and is it "up to date"?
    	if (haveUpToDateGearDrop()) {
    		GearDrop gearDrop = getGearDrop();    		    		
    		
        	// If we do, figure out what to do.  
    		// if we are not facing the gear drop, turn to face it
    		
    		// if the angle we would need to turn is too great, ...
    		
    		// else turn by that angle
    		
    		// If our left/right offset is within
        	// tolerance, just drive forward at it
        	// If our left/right offset is outside tolerance, rotate, drive towards the perpendicular
        	// then rotate back again.  Then detect the gear drop again to make sure we got it right.    		
    		
        	if (gearDropIsOffsetTooMuch(gearDrop)) {  
        		double angle = computeAngleToGearDropPerpendicular(gearDrop) / 2; // half the angle
        		double distance = Math.cos(angle) / gearDrop.offsetFromCenter;
        		command = new AlignToGearDropCommand(angle, distance);
        	}   
        	else { // drive straight at it
        		// if distance is more than 36 inches, only go 24 inches then check again
        		// otherwise go right at it
        		double distance = gearDrop.distanceFromTarget;
        		if (distance >= CUTOFF_DISTANCE) {
        			distance = distance - CUTOFF_DISTANCE;
        		}
        		command = new DriveForwardByDistanceCommand(distance);
        	}
    	}
    	// were we just trying to locate the gearDrop?  Seems we can't.  Let's do a little scan back and forth
    	else if (currentCommand != null && currentCommand instanceof LocateGearDropUsingVisionCommand) { // if we just looked for the gear drop and didn't find it, rotate by a few degrees and then look again
    		int ctr = 0;
    		if (lastSearchAngleCtr <= -2) {
    			ctr = 3;	// rotate back then by angle
    		}
    		else if (lastSearchAngleCtr < 0) { // rotate ccw
    			ctr--;	
    		}
    		else if (lastSearchAngleCtr < 2){ // keep rotating cw
    			ctr++;
    		}
    		else {
    			// did not find
    			ctr = 0;
    		}
    		if (ctr == 0) {
    			command = null;
    		}
    		else {
        		command = new RotateByAngleCommand(Math.toRadians(SEARCH_ANGLE_DEGREES * ctr));    			
    		}
    		lastSearchAngleCtr = ctr;
    	}    	
    	else { // try to detect gear drop
        	command = new LocateGearDropUsingVisionCommand(5, this); // first, find the geardrop
    	}    	
    	if (command != null) {
    		addSequential(command);
    		SmartDashboard.putString(OI.GEARFINDER_MODE, command.getClass().getSimpleName());
    	}
    	else {
    		SmartDashboard.putString(OI.GEARFINDER_MODE, "NONE");
    	}
    	return command;
    }
    
    private boolean haveUpToDateGearDrop() {
    	return gearDrop != null && (System.currentTimeMillis() - gearDrop.timestamp < MAX_GEARDROP_AGE);
	}

	protected double computeAngleToGearDropPerpendicular(GearDrop gearDrop) {
    	// FIXME this comp - need something less than 90
    	return Math.PI / 2;
    }
    
    protected GearDrop getGearDrop() {
    	return gearDrop;
    }
    
    protected void searchForGearDrop() {
		// TODO Auto-generated method stub
		// how do we search?  turn around until we see it?  how fast can we turn?
    	LOGGER.info("Search for gear drop gain "+RobotMap.GEAR_SEARCH_GAIN );
    	Robot.driveLine.turnInPlace(RobotMap.GEAR_SEARCH_GAIN);
	}
    
    protected void approachGearDrop() {
		double speed = 0;
		double curve = 0;
		double curveGain = SmartDashboard.getNumber(OI.GEARFINDER_CURVE_GAIN, RobotMap.GEAR_APPROACH_CURVE_GAIN);
		double speedGain = SmartDashboard.getNumber(OI.GEARFINDER_SPEED_GAIN, RobotMap.GEAR_APPROACH_SPEED_GAIN);

		if (gearDrop == null) {
			LOGGER.info("No gear drop");	
			return;
		}
		else {
			
			// as a percentage
			speed = (gearDrop.distanceFromTarget - Settings.TARGET_DISTANCE_IN_M) * speedGain;
			
			speed =  Math.max(- MAX_SPEED, Math.min(MAX_SPEED,  speed));	
			
			if (speed > 0) speed = Math.max(speed, MIN_SPEED);
			else if (speed < 0) speed = Math.min(speed, -MIN_SPEED);
			
			// is it offset left? turn CCW meaning increase right speed and decrease left		
			// is it offset right? turn CW meaning increase left speed and decrease right		
			// max turn speed at 1/4 width
	
			curve += Math.max(-1, Math.min(1, -gearDrop.offsetAsPercentage[0] * curveGain ));
			
			// is left side smaller?  turn CW if leftRightSizeDiff < 1
			// is right side smaller?  turn CCW if leftRightSizeDiff > 1
			// max turn speed at +/-25%
	//			curve += Math.max(1, Math.min(-1, (1 - gearDrop.leftRightSizeDiff) * 4));
			
			LOGGER.info(String.format("Drive at %.1f curve %.1f", -speed, curve));
			Robot.driveLine.drive(-speed, curve);
		}

	}
    
    public void execute() {
    	super.execute();
    	evaluateNextCommand();
    }
    
	@Override
	public void setGearDrop(GearDrop gearDrop) {
		this.gearDrop = gearDrop;		
	}

}
